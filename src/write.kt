package tiduna;

import kotlin.io.*;
import java.io.*;

val CHAR_SIZE = 6; // size of each individual character (including whitespace around it)

data class Voxel(val x: Int, val y: Int, val z: Int, val r: UByte, val g: UByte, val b: UByte) {
	fun text(): String = "%d %d %d %02x%02x%02x".format(x, y, z, r.toByte(), g.toByte(), b.toByte());
}

fun parse(txt: String): List<Voxel> {
	val ret = mutableListOf<Voxel>();
	for(line in txt.lines()) {
		if(line.startsWith("#"))
			continue; // comment
		val split = line.split(" ");
		if(split.size != 4)
			continue; // invalid line?
		val x = split[0].toInt();
		val y = split[1].toInt();
		val z = split[2].toInt();
		val col = split[3].chunked(2).map { it.toInt(16).toUByte() };
		ret.add(Voxel(x, y, z, col[0], col[1], col[2]));
	}
	return ret;
}

fun toFile(list: List<Voxel>) = buildString {
	appendLine("# Generated by write.kt");
	for(vox in list)
		appendLine(vox.text());
}

val vowels = setOf('a', 'A', 'e', 'i', 'u');

fun main(args: Array<String>) {
	if(args.size != 2) {
		println("Usage: write <phrase> <output file>");
		return;
	}
	val phrase = Parser(args[0]).parse();
	val output = args[1];
	// load script
	val script = mutableMapOf<Char, List<Voxel>>();
	for(file in File("./script").listFiles()) {
		if(file.extension != "txt")
			continue;
		val letter = file.nameWithoutExtension[0];
		script[letter] = parse(file.readText());
	}
	// create tie character (-)
	run {
		val tie = mutableListOf<Voxel>();
		for(i in 0..CHAR_SIZE) {
			tie.add(Voxel(i, CHAR_SIZE/2-1, CHAR_SIZE/2-1, 255u, 255u, 255u));
		}
		script['-'] = tie;
	}
	// find max length of any compound
	var maxLen = 0;
	fun findMaxLen(t: Tree) {
		when(t) {
			is Tree.Compound -> {
				if(t.descriptors.size > maxLen)
					maxLen = t.descriptors.size;
			}
			is Tree.Phrase -> {
				for(c in t.children)
					findMaxLen(c);
			}
			else -> {}
		}
	}
	findMaxLen(phrase);
	val ret = mutableListOf<Voxel>();
	// convert
	var x = 0;
	val groupZ = maxLen*2*CHAR_SIZE+CHAR_SIZE;
	fun place(char: Char, x: Int, y: Int, z: Int) {
		for(vox in script[char]!!) {
			ret.add(vox.copy(x = vox.x+x, y = vox.y+y, z = vox.z+z));
		}
	}
	fun convert(t: Tree, depth: Int = 0) {
		when(t) {
			is Tree.Compound -> {
				t.descriptors.forEachIndexed { i, desc ->
					var y = 0;
					for(j in 0..<desc.length) {
						val c = desc[j];
						// draw vowel below if necessary
						if(c in vowels && j > 0 && desc[j-1] !in vowels) {
							place(c, x, y, CHAR_SIZE*2*i+1);
							y += CHAR_SIZE;
							continue;
						}
						place(c, x, y, CHAR_SIZE*2*i+CHAR_SIZE);
						if(j < desc.length-1 && desc[j+1] !in vowels) {
							y += CHAR_SIZE;
						}
					}
				}
				for(i in 0..<depth) {
					place('-', x, 0, groupZ+i*CHAR_SIZE);
				}
				x += CHAR_SIZE;
			}
			is Tree.Phrase -> run {
				for(c in t.children) {
					convert(c, depth+if(t.sound == null) 0 else 1);
				}
			}
			Tree.Period -> {
				x += CHAR_SIZE;
			}
		}
	}
	convert(phrase);
	File(output).writeText(toFile(ret));
}
